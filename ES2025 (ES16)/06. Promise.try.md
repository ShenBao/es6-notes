# Promise.try

Promise.try 这个提案用于简化同步和异步函数的统一处理。它将任意函数包装在一个 Promise 中，确保函数在当前调用栈中执行，并返回一个 Promise，处理可能的返回值或异常。

简单来说，Promise.try() 是一个静态方法，它能把任何函数（同步的、异步的、返回值的、抛异常的）包装成一个 Promise。无论这个函数是同步还是异步，Promise.try() 都能轻松搞定，还能自动捕获同步异常，避免错误遗漏。

## 动机

- 现有问题：使用 Promise.resolve().then(f) 会导致函数 f 异步调用，而 new Promise(resolve => resolve(f())) 使用不便。
- 解决方案：Promise.try(f) 提供了简洁的 API，同步执行函数，并处理生成的 Promise。

## 主要功能

- 同步执行函数 f。
- 包装返回值或异常为 Promise，支持链式操作。

## 语法

```js
Promise.try(func)
Promise.try(func, arg1)
Promise.try(func, arg1, arg2)
Promise.try(func, arg1, arg2, /* …, */ argN)
```

参数 func：
- 要包装的函数，可以是同步的，也可以是异步的。
- arg1、arg2、…、argN：传给 func 的参数。

返回值: 一个 Promise，可能的状态有：
- 如果 func 同步返回一个值，Promise 就是已兑现的。
- 如果 func 同步抛出一个错误，Promise 就是已拒绝的。
- 如果 func 返回一个 Promise，那就按这个 Promise 的状态来。

## 为什么需要 Promise.try()？

在实际开发中，我们经常遇到一种情况：不知道或者不想区分函数是同步还是异步，但又想用 Promise 来处理它。

以前，我们可能会用 Promise.resolve().then(f)，但这会让同步函数变成异步执行，有点不太理想。

```js
const f = () => console.log('now');
Promise.resolve().then(f);
console.log('next');
// next
// now
```

上面的代码中，函数 f 是同步的，但用 Promise 包装后，它变成了异步执行。

有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？

答案是可以的，并且 Promise.try() 就是这个方法！

## 示例

同步函数：

```js
function syncFunction() {
  return 42;
}

Promise.try(syncFunction)
  .then(console.log) // 输出：42
  .catch(console.error);
```

异步函数：

```js
async function asyncFunction() {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve('异步的结果');
    }, 1000);
  });
};
}

Promise.try(asyncFunction)
  .then(result =>console.log(result)) // 1秒后输出：异步的结果
  .catch(error =>console.error(error));
```

处理异常：

```js
function riskyFunction() {
  throw new Error("Error!");
}

Promise.try(riskyFunction).then(console.log).catch(console.error); // 输出：Error: Error!
```

## Promise.try() 的优势

- 统一处理同步和异步函数：不管函数是同步还是异步，Promise.try() 都能轻松搞定，代码更简洁。
- 异常处理：自动捕获同步异常，错误处理更直观，避免遗漏。
- 代码简洁：相比传统方法，Promise.try() 让代码更易读易维护。

## 实际应用场景

### 场景 1：统一处理 API 请求

```js
function fetchData(url) {
  return Promise.try(() => fetch(url))
    .then(response => response.json())
    .catch(error => console.error('请求失败:', error));
}

fetchData('https://api.example.com/data')
  .then(data => console.log('数据:', data));
```

### 场景 2：混合同步和异步操作

```js
const syncTask = () => '同步任务完成';
const asyncTask = () => new Promise(resolve => setTimeout(() => resolve('异步任务完成'), 1000));

Promise.try(syncTask)
  .then(result => console.log(result)) // 输出：同步任务完成
  .then(() => Promise.try(asyncTask))
  .then(result => console.log(result)) // 1秒后输出：异步任务完成
  .catch(error => console.error(error));
```

### 场景 3：处理数据库查询

```js
function getUser(userId) {
  return Promise.try(() => database.users.get({ id: userId }))
    .then(user => user.name)
    .catch(error => console.error('数据库查询失败:', error));
}

getUser('123')
  .then(name => console.log('用户名称:', name));
```

### 场景 4：处理文件读取

```js
function readFile(path) {
  return Promise.try(() => fs.readFileSync(path, 'utf8'))
    .catch(error => console.error('文件读取失败:', error));
}

readFile('example.txt')
  .then(content => console.log('文件内容:', content));
```

## 总结

Promise.try() 的引入让异步编程变得更加简单和优雅。

它统一了同步和异步函数的处理方式，简化了错误处理，让代码更易读易维护。


## 链接

- 地址：https://github.com/tc39/proposal-promise-try
- http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/
- https://twitter.com/RReverser/status/695678489937186816
