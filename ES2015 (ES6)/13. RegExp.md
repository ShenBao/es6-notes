# RegExp

- i 忽略大小写
- m 多行匹配
- g 全局匹配

## Regexp Sticky（y 修饰符）

ES6 为正则表达式添加了 `y` 修饰符，叫做"粘连"（sticky）修饰符。

y 修饰符的作用与 g 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g 修饰符只要剩余位置中存在匹配就可，而 y 修饰符确保匹配必须从剩余的第一个位置开始，这也就是"粘连"的涵义。

- sticky 粘连：从上次匹配完剩余字符串的第一位开始匹配，可以连续匹配
- `^表示起始位置，$表示结束位置`。

```JS
const s = 'aaa_aa_a'
const r1 = /a+/g // 每次匹配剩余的
const r2 = /a+/y // 剩余的第一个开始匹配

r1.exec(s) // ["aaa"]
r2.exec(s) // ["aaa"]

r1.exec(s) // ["aa"]
r2.exec(s) // null
```

上面代码有两个正则表达式，一个使用 g 修饰符，另一个使用 y 修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是\_aa_a。由于 g 修饰没有位置要求，所以第二次执行会返回结果，而 y 修饰符要求匹配必须从头部开始，所以返回 null。

如果改一下正则表达式，保证每次都能头部匹配，y 修饰符就会返回结果了。

```js
const s = 'aaa_aa_a';
const r = /a+_/y;

r.exec(s); // ["aaa_"]
r.exec(s); // ["aa_"]
```

上面代码每次匹配，都是从剩余字符串的头部开始。

使用 lastIndex 属性，可以更好地说明 y 修饰符。

```js
const regexp = /a/g;

// 指定从2号位置（y）开始匹配
regexp.lastIndex = 2;

// 匹配成功
const match = regexp.exec('xaya');

// 在3号位置匹配成功
console.log(match.index); // 3

// 下一次匹配从4号位开始
console.log(regexp.lastIndex); // 4

// 4号位开始匹配失败
regexp.exec('xaxa'); // null
```

上面代码中，lastIndex 属性指定每次搜索的开始位置，g 修饰符从这个位置开始向后搜索，直到发现匹配为止。

y 修饰符同样遵守 lastIndex 属性，但是要求必须在 lastIndex 指定的位置发现匹配。

```js
const regexp = /a/y;

// 指定从2号位置开始匹配
regexp.lastIndex = 2;

// 不是粘连，匹配失败
regexp.exec('xaya'); // null

// 指定从3号位置开始匹配
regexp.lastIndex = 3;

// 3号位置是粘连，匹配成功
const match = regexp.exec('xaxa');
console.log(match.index); // 3
console.log(regexp.lastIndex); // 4
```

进一步说，y 修饰符号隐含了头部匹配的标志^。

```js
const reg = /b/y;
reg.exec('aba');
// null
console.log(reg.lastIndex);
```

sticky 模式在正则匹配过程中只会影响两件事：

- 匹配必须从 re.lastIndex 开始（相当于正则表达中的 ^）
- 如果匹配到会修改 re.lastIndex（相当于 g 模式）

## Regexp Unicode（u 修饰符）

ES6 为正则表达式添加了 u 修饰符，含义为"Unicode 模式"，用来正确处理大于 \uFFFF 的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。

- 处理 Unicode 字符的，**所有中文都加 u**

```js
/^\uD83D/u.test('\uD83D\uDC2A') // false

/^\uD83D/.test('\uD83D\uDC2A') // true

const str = '\uD842\uDFB7' // 表示一个字符
console.log(/^\uD842/.test(str)) // es5 true
console.log(/^\uD842/u.test(str)) // es6 false
```

上面代码中， \uD83D\uDC2A 是一个四个字节的 UTF-16 编码，代表一个字符 "🐪"。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为 true。加了 u 修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为 false。

一旦加上 u 修饰符号，就会修改下面这些正则表达式的行为。

### (1) 点字符

点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于 0xFFFF 的 Unicode 字符，点字符不能识别，必须加上 u 修饰符。

```js
const str = '\uD842\uDFB7';

console.log(/^.$/.test(str)); // false
console.log(/^.$/u.test(str)); // true
```

上面代码表示，如果不添加 u 修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。

`'𠮷'这个字读 jí，是'吉'字的异形体，Unicode 码点 U+20BB7`

### (2) Unicode 字符表示法

ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上 u 修饰符，才能识别。

```js
console.log(/\u{61}/.test('a')); // false
console.log(/\u{61}/u.test('a')); // true
```

上面代码表示，如果不加 u 修饰符，正则表达式无法识别\u{61}这种表示法，只会认为这匹配 61 个连续的 u。

### (3) 量词

使用 u 修饰符后，所有量词都会正确识别码点大于 0xFFFF 的 Unicode 字符。

```js
/a{2}/.test('aa') // true
/a{2}/u.test('aa') // true

console.log(/𠮷{2}/.test('𠮷𠮷')) // false
console.log(/𠮷{2}/u.test('𠮷𠮷')) // true
```

另外，只有在使用 u 修饰符的情况下，Unicode 表达式当中的大括号才会被正确解读，否则会被解读为量词。

```js
/^\u{3}$/.test('uuu'); // true
```

上面代码中，由于正则表达式没有 u 修饰符，所以大括号被解读为量词。加上 u 修饰符，就会被解读为 Unicode 表达式。

```js
/\u{20BB7}{2}/u.test('𠮷𠮷'); // true
```

使用 u 修饰符之后 Unicode 表达式+量词也是可以的。

### (4) 预定义模式

u 修饰符也影响到预定义模式，能否正确识别码点大于 0xFFFF 的 Unicode 字符.

```js
console.log(/^\S$/.test('𠮷')); // false
console.log(/^\S$/u.test('𠮷')); // true
```

上面代码的\S 是预定义模式，匹配所有不是空格的字符。只有加了 u 修饰符，它才能正确匹配码点大于 0xFFFF 的 Unicode 字符。

利用这一点，可以写出一个正确返回字符串长度的函数。

```js
function codePointLength(text) {
  const result = text.match(/[\s\S]/gu);
  return result ? result.length : 0;
}

const s = '𠮷𠮷';

console.log(s.length); // 4
console.log(codePointLength(s)); // 2
```

### (5) i 修饰符

有些 Unicode 字符的编码不同，但是字型很相近，比如，\u004B 与\u212A 都是大写的 K。

```js
console.log(/[a-z]/i.test('\u212A')); // false
console.log(/[a-z]/iu.test('\u212A')); // true
```

上面代码中，不加 u 修饰符，就无法识别非规范的 K 字符。

code

```JS
// unicode u修饰符 大于 \uffff
let s = '𠮷';
let s2 = '\uD842\uDF87';

console.log(/^\uD842/.test(s2));
console.log(/^\uD842/u.test(s2)); // 无法匹配

console.log(/^.$/.test(s)); // 无法匹配
console.log(/^.$/u.test(s)); // 正确匹配, 使用 "." 大于两个字节要加 u

console.log(/^\u{20BB7}$/u.test(s));
console.log(/^\u{61}$/u.test('a')); // 使用码点时，加 u 才能匹配 \u

console.log(/𠮷{2}/u.test('𠮷𠮷')); // 加 u 才能匹配，所有中文都加 u

console.log(/[a-z]/i.test('\u212A'));
console.log(/[a-z]/iu.test('\u212A'));
```

## 链接

- [Unicode 与 JavaScript 详解](http://www.ruanyifeng.com/blog/2014/12/unicode.html)
- [New regular expression features in ECMAScript 6](http://2ality.com/2015/07/regexp-es6.html)
- [RegExp.prototype.sticky](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky)
